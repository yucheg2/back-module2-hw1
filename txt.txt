в ноде есть 2 основных типа модулей :
1) встроенные модули в саму программу node.js (
мы можем обращаться к этим модулям из любых мест 
)
2) сторонние модули, которые мы устанавливаем через npm 

чтобы использовать сторонние пакеты, нам нужно вести корректный список
этих зависимостей. мы делаем это в файле packaje.json 

сгенерируем его через "npm init" в консоли

мы попадаем в интерактивную консоль, куда мы должны вписать базовые 
значения в packaje

package name: (3.-как-работают-модули) node-app
version: (1.0.0)
description: this is simple node.js application
entry point: (index.js)
test command:
git repository:
keywords: node, js
author: Yucheg <prostoyurka1223@gmail.com>// вот так указывается автор и 
// почта
license: (ISC)

сгенерируется файл 

далее мы установим некоторые пакеты

установим yargs
npm i yargs

чтобы работать с этим пакетом, мы создадим константу, в которую поместим
содержимое пакета

в index.js

const yargs = require("yargs")

//4. Чтение параметров консоли

сейчас мы создаем с нуля маленькую консольную программму

yargs очень сильно нам поможет с чтением параметров и с формулированием
документации

для начала вызовем метод command у yargs
(если ide не будет видеть методы стороннего пакета, то к нему можно 
скачать типы, чтобы они у нас автоматически подсвечивались
npm i @types/yargs (через слеш название пакета к которому мы хотим 
подсказки)
)

yargs.command({
    
})

в объект, который мы передаем в метод нужно написать как минимум 3 
свойства


yargs.command({
    command: "",// название команды
    describe: "",// описание
    handler() {
        
    }// функция, которая выполняется при вызове команды
})

в рамках нашего приложения мы создадим небольшую базу данных
заметок

создадим комманду, которая будет добавлять новую заметку

yargs.command({// создаем команду 
    command: "add",//название команды
    describe: "Add new note to list",//описание команды
    handler() {
        console.log("add command")
    }// что эта команда выполняет
})

сейчас просто выведем какой-либо текст в консоль

так-же создадим команду, которая будет давать список команд

yargs.command({
    command: "list",
    describe: "Print all notes",
    handler() {
        console.log("list command")
    }
})

и теперь мы можем обратится к node.js, вызвать нащ файл index.js и тут же
передать комманду, которую мы хотим выполнить

node index.js add (вызвали команду add из файла index.js)

сейчас ничего не произойдет, тк нам нужно их, грубо говоря, 
проинициализировать

для этого существует метод parse

yargs.parse()

снова вызовем команду

и она выполнится и выведет в консоль то, что мы написали

то есть мы передаем в команду для ноды название команды, которую мы 
создали и yargs вызывает хендлер к команде с этим названием

так-же мы можем посмотреть список всех команд и описание, которые мы им 
передовали, вызвав документацию к файлу index

node index --help

так-же мы можем указывать версию нашего строчного приложения 

const pkg = require("./package.json")//импортировали объект packaje
(в котором все зависимости, версия, скрипты и тд.)

yargs.version(pkg.version)//указываем версию нашего строчного приложения,
// соответствующую параметру из package.json

и так в нашу команду по добавлению записки нам нужно передовать параметры

для этого в объект для command мы передаем еще объект builder
(мы не можем передавать параметры в handler, тк передача их идет из 
консоли)

yargs.command({ 
    command: "add",
    describe: "Add new note to list",
    builder: {
        title:{
            type: "string",//тип данных передаваемых в параметр
            describe: "Note title",//описание параметра
            demandOption: true//обязателен ли параметр для команды
        }//ключ к объекту - название параметра
    },//параметры которые мы передаем через командную строку
    handler() {
        console.log("joj")
    }
})

мы теперь можем вызвать инструкцию к этой команде
node index.js add --help

нам выведится описание команды, и ее опции

теперь в хендлере мы получаем объект option в параметры, мы можем его 
сразу деструктуризировать

yargs.command({
    command: "add",
    describe: "Add new note to list",
    builder: {
        title:{
            type: "string",
            describe: "Note title",
            demandOption: true
        }
    },
    handler({title}) {
        console.log(title)// выведем в консоль строку, которую передадим
        // через команду
    }
})

теперь у нас выводится в консоль, то что мы передаем как параметр в 
команде

node index.js add --title someText

//5. Запись в файл

сейчас мы напишем функционал для консольного приложения
(вывод списка, добовление новых записей и тд). Создадим 
отдельный файл для этого notes.controller.js

function addNote(str) {
    
}

function getNotes(str) {
    
}

файл содержит функции для работы приложения. 

теперь нам нужно экспортировать эти функции старым способом, чтобы они 
пришли через старый импорт (require)

это делается через глобальный объект module

function addNote(str) {
    
}

function getNotes(str) {
    
}

module.exports = {
    addNote, getNotes
}//экспортируем объект 

изначально все переменные и функции в файле являются приватными и они 
видны только внутри этого файла(модуля). и обращаясь к этому модулю, мы 
говорим, какие сущности будут видны другим файлам

теперь мы импортируем эти функции внутрь команд

const { addNote, getNotes } = require("./notes.controller")
//импортировали обычной деструктуризацией

далее напишим логику приложения

const notes = []//масив записок

function addNote(title) {
    const note = {
        title,
        id: Date.now().toString()
    }// генерируем объект записок

    notes.push(note)// пушим новую записку
}

function getNotes() {
    return notes// возвращаем список записок
}

module.export = {
    addNote, getNotes
}

далее мы вызовем нужную функцию в хендлере команды


yargs.command({
    command: "list",
    describe: "Print all notes",
    handler() {
        const notes = getNotes()//функция возвращает масив записок
        console.log(notes)//выведем его в консоль
    }
})

мы получим пустой масив, теперь попробуем добавить записку

yargs.command({
    command: "add",
    describe: "Add new note to list",
    builder: {
        title:{
            type: "string",
            describe: "Note title",
            demandOption: true
        }
    },
    handler({title}) {
        addNote(title)
    }
})

вызовем команду добавления и потом вызовем список записок

мы получим пустой масив, несмотря на то, что ранее мы вызвали функцию 
добавления пушащую сущность записки в масив 

на самом деле тут ошибки нет, тк после того, как мы вызовем команду через
node, она посел выполнения сразу прекратит свое состояния и все значения
збросятся к дефолтным. и по этому когда мы вызываем список после 
добавления мы получаем пустой масив, тк это следующая итерация ноды а не 
предыдущая(в которой мы добавили записку)

нам нужно чтобы данные сохранялись между разными командами

создадим файл, который будет являтся нашей базой данных.
db.json

[] 

по умолчанию в нашей базе данных будет просто пустой файл

теперь мы можем запросить ее в наших функциях и работать с ней
в notes.controller.js

function addNote(title) {
    const notes = require("./db.json")//получаем базу данных

    const note = {
        title,
        id: Date.now().toString()
    }

    notes.push(note)
}

function getNotes() {
    return require("./db.json")
}

module.exports = {
    addNote, getNotes
}

попробуем снова вызвать добавление и посмотрим в json файл

мы увидем, что файл не изменился

сейчас мы просто пушим информацию в масив, который мы получили,
но не записываем ничего в сам файл

и чтобы записать это в файл мы можем использовать стандартные модули в 
node.js 

один из них - это fs(file sistem)

импортируем его, как сторонний пакет(типа yargs) в notes.controller.js

const fs = require("fs")

так мы импортируем версию с колбеками, но мы можем работать с версией
с промисами

const fs = require("fs/promises")//версия с промисами

и сейчас мы можем применять async await

проговарим логику функциии.

мы получаем дынные из базы, потом создаем объект для занесения его в масив
, далее пушим объект в масив(который скопирован из базы данных) и теперь 
нам нужно перезаписать весь масив на тот, который мы сделали в конце 
предыдущей логики (масив который копирует масив из базы и получает 
в конец новый объект)

для перезаписи файла мы воспользуемся методом fs.writeFile

function addNote(title) {
    const notes = require("./db.json")

    const note = {
        title,
        id: Date.now().toString()
    }

    notes.push(note)

    fs.writeFile("./db.json", JSON.stringify(notes))
    // 1й параметр - путь к файлу, который мы хотим перезаписать
    // 2й - что будет вместо старой информации. это должна быть json 
    // строчка(в файл запишется эта строчка)
}

так-же этот метож является асинхронным, такчто подождем его выполнения

async function addNote(title) {
    const notes = require("./db.json")

    const note = {
        title,
        id: Date.now().toString()
    }

    notes.push(note)

    await fs.writeFile("./db.json", JSON.stringify(notes))
}

снова попробуем добавить записку и посмотрим в db.json

мы увидем, что в файле теперь содержится строчка кода, которую мы 
перенесли в функции(в файл записывается эта строчка не как строка, а
именно как строка кода)

теперь мы можем посмотреть масив через командк и нас выдастся масив из 
db.json

//6. Чтение из файла

улучшим наше приложение. 

сейчас у нас есть проблема с строчкой "./db.json", которую мы передаем в 
функцию

    await fs.writeFile("./db.json", JSON.stringify(notes))

тк node.js может работать на разных платформах, в разных окружениях и 
эта строча может стать ошибкой, тк в этой строчке мы описываем 
относительный путь и разные сборщики могут занести наши файлы с базой 
данных в одну папку, а файл с функцией в другую и так не сработает этот 
относительный путь, тк он указывает на текущую папку

по этому нам пригодится следующий стандартный пакет из ноды
path

const path = require("path")

теперь создадим константу notesPath

const notesPath = path.join(__dirname, "db.json")
//корректный путь к масиву записей
//1й параметр - путь к нашей директории(используем глобальный объект)
//2й - название файла (если он внутри папки в текущей директории 
// по очереди указываем название папки и файла в конце)

мы можем вывести в консоль этот параметр и он коректно напишет полный путь

заменим теперь на этот путь, который будет подстраиваться под окружения 

const notesPath = path.join(__dirname, "db.json")

async function addNote(title) {
    const notes = require(notesPath)

    const note = {
        title,
        id: Date.now().toString()
    }

    notes.push(note)

    await fs.writeFile(notesPath, JSON.stringify(notes))
}

далле мы можем читать любые файлы, не только json 

для этого мы используем fs.readFile

async function addNote(title) {
    fs.readFile()
}

addNote("test")

сейчас мы будем отдельно запускать только notes.controller.js 
и тестировать эту функцию

async function addNote(title) {

    const notes = await fs.readFile(notesPath)
    console.log(notes)
}

addNote("test")

в консоли у нас высветится следующее

<Buffer 5b 7b 22 74 69 74 6c 65 22 3a 22 61 62 6f 62 61 22 2c 22 69 64 22 
3a 22 31 36 38 37 39 37 33 31 37 33 33 37 38 22 7d 2c 7b 22 74 69 74 6c 65
22 3a 22 ... 78 more bytes>

и так по умолчанию мы получаем буфер

теперь мы можем раскодировать этот буфер

    const decodeBoofer = Buffer.from(notes).toString("utf-8")

обращаемся к глобальному объекту буфер, к методу фром, указываем в него 
то, что мы хотим декодировать и далее переводим это в строчку по кодировке
utf-8

и выведя это в консоль мы наконец получим строчку масив записей в виде
строчки

но нам нужен именно масив, поэтому распарсим эту строку

    console.log(JSON.parse(decodeBoofer))

весь этот код по получению масива можно свести к одной строчке

    const notes = await fs.readFile(notesPath, {encoding: "utf-8"})
    //декодируем буфер по utf-8

    console.log(JSON.parse(notes))

теперь мы можем перенести этот способ получения заметок в функцию 
getNotes, чтобы оптимизировать проект

async function getNotes() {
    
    const notes = await fs.readFile(notesPath, {encoding: "utf-8"})

    return notes
}

добавим проверку для отработки ситуаций, когда в читаемом файле вообще 
нет ничего

async function getNotes() {
    
    const notes = await fs.readFile(notesPath, {encoding: "utf-8"})

    return Array.isArray(JSON.parse(notes)) ? JSON.parse(notes) : []
}

и теперь мы можем получить записи, подождав, когда выполнится метод 
getNotes

    const notes = await getNotes()
    console.log(notes)

теперь попробуем снова создать функцию для отправки объекта
записки

async function addNote(title) {

    const notes = await getNotes()

    const note = {
        title,
        id: Date.now().toString()
    }

    notes.push(note)

    await fs.writeFile(notesPath, JSON.stringify(notes))
}

единственный сечас недостаток, это то, что функция получения масива 
возвращает промис и мы можем просто подождать, чтобы получить нормальный
результат

//7. Вывод данных

установим chalk для нашего проекта 
npm i chalk

этот пакет позволяет делать красивую консоль

например, когда мы добовляем заметку, было бы неплохо получить в ответ
какоенибудь сообщение

подключим пакет в notes.controller.js

const chalk = require("chalk")

и теперь мы можем в функции добавления после её выполнения написать в 
консоли  зеленый текст

const chalk = require("chalk")

async function addNote(title) {

    const notes = await getNotes()

    const note = {
        title,
        id: Date.now().toString()
    }

    notes.push(note)

    await fs.writeFile(notesPath, JSON.stringify(notes))
    console.log(chalk.green.inverse("Note added!"))
}

invers - делает цвет заднего фона текста(без него просто текст становится
указанного цвета)

теперь изменим то, что у нас выводит консоль при запросе списка
будем экспортировать не getNotes, а другую функцию для прорисовки 
списка

async function printNotes() {
    const notes = await getNotes()

    console.log(chalk.bgBlue("List of notes:"))
    notes.forEach(note => {
        console.log(chalk.blue(note.title))
    });
}

теперь у нас в начале идет надпись и по очереди выводим все title у 
notes